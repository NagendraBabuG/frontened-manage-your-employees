{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fCallArguments = exports.transformCommandReply = exports.transformLegacyCommandArguments = exports.transformCommandArguments = exports.attachExtensions = exports.attachCommands = void 0;\n\nconst command_options_1 = require(\"./command-options\");\n\nfunction attachCommands(_ref) {\n  let {\n    BaseClass,\n    commands,\n    executor\n  } = _ref;\n\n  for (const [name, command] of Object.entries(commands)) {\n    BaseClass.prototype[name] = function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return executor.call(this, command, args, name);\n    };\n  }\n}\n\nexports.attachCommands = attachCommands;\n\nfunction attachExtensions(config) {\n  let Commander;\n\n  if (config.modules) {\n    Commander = attachWithNamespaces({\n      BaseClass: config.BaseClass,\n      namespaces: config.modules,\n      executor: config.modulesExecutor\n    });\n  }\n\n  if (config.functions) {\n    Commander = attachWithNamespaces({\n      BaseClass: Commander ?? config.BaseClass,\n      namespaces: config.functions,\n      executor: config.functionsExecutor\n    });\n  }\n\n  if (config.scripts) {\n    Commander ?? (Commander = class extends config.BaseClass {});\n    attachCommands({\n      BaseClass: Commander,\n      commands: config.scripts,\n      executor: config.scriptsExecutor\n    });\n  }\n\n  return Commander ?? config.BaseClass;\n}\n\nexports.attachExtensions = attachExtensions;\n\nfunction attachWithNamespaces(_ref2) {\n  let {\n    BaseClass,\n    namespaces,\n    executor\n  } = _ref2;\n  const Commander = class extends BaseClass {\n    constructor() {\n      super(...arguments);\n\n      for (const namespace of Object.keys(namespaces)) {\n        this[namespace] = Object.create(this[namespace], {\n          self: {\n            value: this\n          }\n        });\n      }\n    }\n\n  };\n\n  for (const [namespace, commands] of Object.entries(namespaces)) {\n    Commander.prototype[namespace] = {};\n\n    for (const [name, command] of Object.entries(commands)) {\n      Commander.prototype[namespace][name] = function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        return executor.call(this.self, command, args, name);\n      };\n    }\n  }\n\n  return Commander;\n}\n\nfunction transformCommandArguments(command, args) {\n  let options;\n\n  if ((0, command_options_1.isCommandOptions)(args[0])) {\n    options = args[0];\n    args = args.slice(1);\n  }\n\n  return {\n    args: command.transformArguments(...args),\n    options\n  };\n}\n\nexports.transformCommandArguments = transformCommandArguments;\n\nfunction transformLegacyCommandArguments(args) {\n  return args.flat().map(arg => {\n    return typeof arg === 'number' || arg instanceof Date ? arg.toString() : arg;\n  });\n}\n\nexports.transformLegacyCommandArguments = transformLegacyCommandArguments;\n\nfunction transformCommandReply(command, rawReply, preserved) {\n  if (!command.transformReply) {\n    return rawReply;\n  }\n\n  return command.transformReply(rawReply, preserved);\n}\n\nexports.transformCommandReply = transformCommandReply;\n\nfunction fCallArguments(name, fn, args) {\n  const actualArgs = [fn.IS_READ_ONLY ? 'FCALL_RO' : 'FCALL', name];\n\n  if (fn.NUMBER_OF_KEYS !== undefined) {\n    actualArgs.push(fn.NUMBER_OF_KEYS.toString());\n  }\n\n  actualArgs.push(...args);\n  return actualArgs;\n}\n\nexports.fCallArguments = fCallArguments;","map":{"version":3,"names":["Object","defineProperty","exports","value","fCallArguments","transformCommandReply","transformLegacyCommandArguments","transformCommandArguments","attachExtensions","attachCommands","command_options_1","require","BaseClass","commands","executor","name","command","entries","prototype","args","call","config","Commander","modules","attachWithNamespaces","namespaces","modulesExecutor","functions","functionsExecutor","scripts","scriptsExecutor","constructor","namespace","keys","create","self","options","isCommandOptions","slice","transformArguments","flat","map","arg","Date","toString","rawReply","preserved","transformReply","fn","actualArgs","IS_READ_ONLY","NUMBER_OF_KEYS","undefined","push"],"sources":["C:/Users/gnage/node_modules/@redis/client/dist/lib/commander.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fCallArguments = exports.transformCommandReply = exports.transformLegacyCommandArguments = exports.transformCommandArguments = exports.attachExtensions = exports.attachCommands = void 0;\nconst command_options_1 = require(\"./command-options\");\nfunction attachCommands({ BaseClass, commands, executor }) {\n    for (const [name, command] of Object.entries(commands)) {\n        BaseClass.prototype[name] = function (...args) {\n            return executor.call(this, command, args, name);\n        };\n    }\n}\nexports.attachCommands = attachCommands;\nfunction attachExtensions(config) {\n    let Commander;\n    if (config.modules) {\n        Commander = attachWithNamespaces({\n            BaseClass: config.BaseClass,\n            namespaces: config.modules,\n            executor: config.modulesExecutor\n        });\n    }\n    if (config.functions) {\n        Commander = attachWithNamespaces({\n            BaseClass: Commander ?? config.BaseClass,\n            namespaces: config.functions,\n            executor: config.functionsExecutor\n        });\n    }\n    if (config.scripts) {\n        Commander ?? (Commander = class extends config.BaseClass {\n        });\n        attachCommands({\n            BaseClass: Commander,\n            commands: config.scripts,\n            executor: config.scriptsExecutor\n        });\n    }\n    return Commander ?? config.BaseClass;\n}\nexports.attachExtensions = attachExtensions;\nfunction attachWithNamespaces({ BaseClass, namespaces, executor }) {\n    const Commander = class extends BaseClass {\n        constructor(...args) {\n            super(...args);\n            for (const namespace of Object.keys(namespaces)) {\n                this[namespace] = Object.create(this[namespace], {\n                    self: {\n                        value: this\n                    }\n                });\n            }\n        }\n    };\n    for (const [namespace, commands] of Object.entries(namespaces)) {\n        Commander.prototype[namespace] = {};\n        for (const [name, command] of Object.entries(commands)) {\n            Commander.prototype[namespace][name] = function (...args) {\n                return executor.call(this.self, command, args, name);\n            };\n        }\n    }\n    return Commander;\n}\nfunction transformCommandArguments(command, args) {\n    let options;\n    if ((0, command_options_1.isCommandOptions)(args[0])) {\n        options = args[0];\n        args = args.slice(1);\n    }\n    return {\n        args: command.transformArguments(...args),\n        options\n    };\n}\nexports.transformCommandArguments = transformCommandArguments;\nfunction transformLegacyCommandArguments(args) {\n    return args.flat().map(arg => {\n        return typeof arg === 'number' || arg instanceof Date ?\n            arg.toString() :\n            arg;\n    });\n}\nexports.transformLegacyCommandArguments = transformLegacyCommandArguments;\nfunction transformCommandReply(command, rawReply, preserved) {\n    if (!command.transformReply) {\n        return rawReply;\n    }\n    return command.transformReply(rawReply, preserved);\n}\nexports.transformCommandReply = transformCommandReply;\nfunction fCallArguments(name, fn, args) {\n    const actualArgs = [\n        fn.IS_READ_ONLY ? 'FCALL_RO' : 'FCALL',\n        name\n    ];\n    if (fn.NUMBER_OF_KEYS !== undefined) {\n        actualArgs.push(fn.NUMBER_OF_KEYS.toString());\n    }\n    actualArgs.push(...args);\n    return actualArgs;\n}\nexports.fCallArguments = fCallArguments;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}